# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from subt_ros/RunStatistics.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import genpy
import geometry_msgs.msg
import subt_ros.msg

class RunStatistics(genpy.Message):
  _md5sum = "11264676593bbe2a91539259310448d4"
  _type = "subt_ros/RunStatistics"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# Competition statistics for the current run

time timestamp						# time since sim bootup

string world_name			# name of the simulation world
subt_ros/Robot[] robots					# list of robot names, platforms, types
subt_ros/Marsupial[] marsupials				# list of marsupial robot pairs
int32 artifacts_found					# number of artifacts successfully scored (aka current score)
int32 robot_count					# number of robots
int32 unique_robot_count				# number of unique base robot platforms utilized

int32 sim_time_elapsed					# sim time since the run started
int32 real_time_elapsed					# real time since the run started
int32 artifact_report_count				# number of unique artifact reports received
int32 duplicate_report_count				# number of duplicate artifact reports received

# the successfully scored artifact report with the least positional error
string closest_artifact_report_name			# artifact model name (e.g., backpack_4)
string closest_artifact_report_type			# artifact type (e.g., TYPE_BACKPACK)
geometry_msgs/Vector3 closest_artifact_report_true_pos	# true position of the artifact, xyz [m]
geometry_msgs/Vector3 closest_artifact_report_reported_pos # reported position of the artifact [m]
float64 closest_artifact_report_distance		# distance error between true and reported positions [m]

# time of the first and last successfully scored artifact reports (sim time since bootup)
float64 first_artifact_report_time
float64 last_artifact_report_time
float64 mean_time_between_successful_artifact_reports	# avg time between successful artifact reports

# distance traversed by robots
subt_ros/RobotMetric greatest_distance_traveled		# individual robot with the largest distance traversed
subt_ros/RobotMetric greatest_euclidean_distance_from_start	# individual robot that traveled the furthest from staging area
float64 total_distance_traveled				# total distance traveled by all robots
subt_ros/RobotMetric greatest_max_vel			# individual robot with the greatest maximum speed
subt_ros/RobotMetric greatest_avg_vel			# individual robot with the greatest average speed

# elevation traversed by robots, calculated with each increment of 5m
subt_ros/RobotMetric greatest_elevation_gain		# individual robot with the greatest elevation gain
subt_ros/RobotMetric greatest_elevation_loss		# individual robot with the greatest elevation loss
float64 total_elevation_gain				# total elevation gain across all robots
float64 total_elevation_loss				# total elevation loss across all robots
subt_ros/RobotMetric max_elevation_reached		# individual robot that traveled to the highest elevation relative to staging area
subt_ros/RobotMetric min_elevation_reached		# individual robot that traveled to the lowest elevation relative to staging area

================================================================================
MSG: subt_ros/Robot
# Information about a robot 

string name 		# name of the robot provided by the team
string platform		# base platform utilized (e.g., X1)
string type		# platform and sensor configuration utilized (e.g., X1_SENSOR_CONFIG_1)

================================================================================
MSG: subt_ros/Marsupial
# A marsupial pair of robots

string parent	# name of the parent (carrying) robot
string child	# name of the child (carried) robot

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: subt_ros/RobotMetric
# A run statistics metric for an individual robot

float64 data	# the numerical metric
string name	# name of the robot the metric is associated with
"""
  __slots__ = ['timestamp','world_name','robots','marsupials','artifacts_found','robot_count','unique_robot_count','sim_time_elapsed','real_time_elapsed','artifact_report_count','duplicate_report_count','closest_artifact_report_name','closest_artifact_report_type','closest_artifact_report_true_pos','closest_artifact_report_reported_pos','closest_artifact_report_distance','first_artifact_report_time','last_artifact_report_time','mean_time_between_successful_artifact_reports','greatest_distance_traveled','greatest_euclidean_distance_from_start','total_distance_traveled','greatest_max_vel','greatest_avg_vel','greatest_elevation_gain','greatest_elevation_loss','total_elevation_gain','total_elevation_loss','max_elevation_reached','min_elevation_reached']
  _slot_types = ['time','string','subt_ros/Robot[]','subt_ros/Marsupial[]','int32','int32','int32','int32','int32','int32','int32','string','string','geometry_msgs/Vector3','geometry_msgs/Vector3','float64','float64','float64','float64','subt_ros/RobotMetric','subt_ros/RobotMetric','float64','subt_ros/RobotMetric','subt_ros/RobotMetric','subt_ros/RobotMetric','subt_ros/RobotMetric','float64','float64','subt_ros/RobotMetric','subt_ros/RobotMetric']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       timestamp,world_name,robots,marsupials,artifacts_found,robot_count,unique_robot_count,sim_time_elapsed,real_time_elapsed,artifact_report_count,duplicate_report_count,closest_artifact_report_name,closest_artifact_report_type,closest_artifact_report_true_pos,closest_artifact_report_reported_pos,closest_artifact_report_distance,first_artifact_report_time,last_artifact_report_time,mean_time_between_successful_artifact_reports,greatest_distance_traveled,greatest_euclidean_distance_from_start,total_distance_traveled,greatest_max_vel,greatest_avg_vel,greatest_elevation_gain,greatest_elevation_loss,total_elevation_gain,total_elevation_loss,max_elevation_reached,min_elevation_reached

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RunStatistics, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.timestamp is None:
        self.timestamp = genpy.Time()
      if self.world_name is None:
        self.world_name = ''
      if self.robots is None:
        self.robots = []
      if self.marsupials is None:
        self.marsupials = []
      if self.artifacts_found is None:
        self.artifacts_found = 0
      if self.robot_count is None:
        self.robot_count = 0
      if self.unique_robot_count is None:
        self.unique_robot_count = 0
      if self.sim_time_elapsed is None:
        self.sim_time_elapsed = 0
      if self.real_time_elapsed is None:
        self.real_time_elapsed = 0
      if self.artifact_report_count is None:
        self.artifact_report_count = 0
      if self.duplicate_report_count is None:
        self.duplicate_report_count = 0
      if self.closest_artifact_report_name is None:
        self.closest_artifact_report_name = ''
      if self.closest_artifact_report_type is None:
        self.closest_artifact_report_type = ''
      if self.closest_artifact_report_true_pos is None:
        self.closest_artifact_report_true_pos = geometry_msgs.msg.Vector3()
      if self.closest_artifact_report_reported_pos is None:
        self.closest_artifact_report_reported_pos = geometry_msgs.msg.Vector3()
      if self.closest_artifact_report_distance is None:
        self.closest_artifact_report_distance = 0.
      if self.first_artifact_report_time is None:
        self.first_artifact_report_time = 0.
      if self.last_artifact_report_time is None:
        self.last_artifact_report_time = 0.
      if self.mean_time_between_successful_artifact_reports is None:
        self.mean_time_between_successful_artifact_reports = 0.
      if self.greatest_distance_traveled is None:
        self.greatest_distance_traveled = subt_ros.msg.RobotMetric()
      if self.greatest_euclidean_distance_from_start is None:
        self.greatest_euclidean_distance_from_start = subt_ros.msg.RobotMetric()
      if self.total_distance_traveled is None:
        self.total_distance_traveled = 0.
      if self.greatest_max_vel is None:
        self.greatest_max_vel = subt_ros.msg.RobotMetric()
      if self.greatest_avg_vel is None:
        self.greatest_avg_vel = subt_ros.msg.RobotMetric()
      if self.greatest_elevation_gain is None:
        self.greatest_elevation_gain = subt_ros.msg.RobotMetric()
      if self.greatest_elevation_loss is None:
        self.greatest_elevation_loss = subt_ros.msg.RobotMetric()
      if self.total_elevation_gain is None:
        self.total_elevation_gain = 0.
      if self.total_elevation_loss is None:
        self.total_elevation_loss = 0.
      if self.max_elevation_reached is None:
        self.max_elevation_reached = subt_ros.msg.RobotMetric()
      if self.min_elevation_reached is None:
        self.min_elevation_reached = subt_ros.msg.RobotMetric()
    else:
      self.timestamp = genpy.Time()
      self.world_name = ''
      self.robots = []
      self.marsupials = []
      self.artifacts_found = 0
      self.robot_count = 0
      self.unique_robot_count = 0
      self.sim_time_elapsed = 0
      self.real_time_elapsed = 0
      self.artifact_report_count = 0
      self.duplicate_report_count = 0
      self.closest_artifact_report_name = ''
      self.closest_artifact_report_type = ''
      self.closest_artifact_report_true_pos = geometry_msgs.msg.Vector3()
      self.closest_artifact_report_reported_pos = geometry_msgs.msg.Vector3()
      self.closest_artifact_report_distance = 0.
      self.first_artifact_report_time = 0.
      self.last_artifact_report_time = 0.
      self.mean_time_between_successful_artifact_reports = 0.
      self.greatest_distance_traveled = subt_ros.msg.RobotMetric()
      self.greatest_euclidean_distance_from_start = subt_ros.msg.RobotMetric()
      self.total_distance_traveled = 0.
      self.greatest_max_vel = subt_ros.msg.RobotMetric()
      self.greatest_avg_vel = subt_ros.msg.RobotMetric()
      self.greatest_elevation_gain = subt_ros.msg.RobotMetric()
      self.greatest_elevation_loss = subt_ros.msg.RobotMetric()
      self.total_elevation_gain = 0.
      self.total_elevation_loss = 0.
      self.max_elevation_reached = subt_ros.msg.RobotMetric()
      self.min_elevation_reached = subt_ros.msg.RobotMetric()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2I().pack(_x.timestamp.secs, _x.timestamp.nsecs))
      _x = self.world_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.robots)
      buff.write(_struct_I.pack(length))
      for val1 in self.robots:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.platform
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.marsupials)
      buff.write(_struct_I.pack(length))
      for val1 in self.marsupials:
        _x = val1.parent
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.child
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7i().pack(_x.artifacts_found, _x.robot_count, _x.unique_robot_count, _x.sim_time_elapsed, _x.real_time_elapsed, _x.artifact_report_count, _x.duplicate_report_count))
      _x = self.closest_artifact_report_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.closest_artifact_report_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_11d().pack(_x.closest_artifact_report_true_pos.x, _x.closest_artifact_report_true_pos.y, _x.closest_artifact_report_true_pos.z, _x.closest_artifact_report_reported_pos.x, _x.closest_artifact_report_reported_pos.y, _x.closest_artifact_report_reported_pos.z, _x.closest_artifact_report_distance, _x.first_artifact_report_time, _x.last_artifact_report_time, _x.mean_time_between_successful_artifact_reports, _x.greatest_distance_traveled.data))
      _x = self.greatest_distance_traveled.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_euclidean_distance_from_start.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_euclidean_distance_from_start.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2d().pack(_x.total_distance_traveled, _x.greatest_max_vel.data))
      _x = self.greatest_max_vel.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_avg_vel.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_avg_vel.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_elevation_gain.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_elevation_gain.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_elevation_loss.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_elevation_loss.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d().pack(_x.total_elevation_gain, _x.total_elevation_loss, _x.max_elevation_reached.data))
      _x = self.max_elevation_reached.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.min_elevation_reached.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.min_elevation_reached.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.timestamp is None:
        self.timestamp = genpy.Time()
      if self.robots is None:
        self.robots = None
      if self.marsupials is None:
        self.marsupials = None
      if self.closest_artifact_report_true_pos is None:
        self.closest_artifact_report_true_pos = geometry_msgs.msg.Vector3()
      if self.closest_artifact_report_reported_pos is None:
        self.closest_artifact_report_reported_pos = geometry_msgs.msg.Vector3()
      if self.greatest_distance_traveled is None:
        self.greatest_distance_traveled = subt_ros.msg.RobotMetric()
      if self.greatest_euclidean_distance_from_start is None:
        self.greatest_euclidean_distance_from_start = subt_ros.msg.RobotMetric()
      if self.greatest_max_vel is None:
        self.greatest_max_vel = subt_ros.msg.RobotMetric()
      if self.greatest_avg_vel is None:
        self.greatest_avg_vel = subt_ros.msg.RobotMetric()
      if self.greatest_elevation_gain is None:
        self.greatest_elevation_gain = subt_ros.msg.RobotMetric()
      if self.greatest_elevation_loss is None:
        self.greatest_elevation_loss = subt_ros.msg.RobotMetric()
      if self.max_elevation_reached is None:
        self.max_elevation_reached = subt_ros.msg.RobotMetric()
      if self.min_elevation_reached is None:
        self.min_elevation_reached = subt_ros.msg.RobotMetric()
      end = 0
      _x = self
      start = end
      end += 8
      (_x.timestamp.secs, _x.timestamp.nsecs,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.world_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.world_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.robots = []
      for i in range(0, length):
        val1 = subt_ros.msg.Robot()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.platform = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.platform = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.type = str[start:end]
        self.robots.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.marsupials = []
      for i in range(0, length):
        val1 = subt_ros.msg.Marsupial()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.parent = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.parent = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.child = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.child = str[start:end]
        self.marsupials.append(val1)
      _x = self
      start = end
      end += 28
      (_x.artifacts_found, _x.robot_count, _x.unique_robot_count, _x.sim_time_elapsed, _x.real_time_elapsed, _x.artifact_report_count, _x.duplicate_report_count,) = _get_struct_7i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.closest_artifact_report_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.closest_artifact_report_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.closest_artifact_report_type = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.closest_artifact_report_type = str[start:end]
      _x = self
      start = end
      end += 88
      (_x.closest_artifact_report_true_pos.x, _x.closest_artifact_report_true_pos.y, _x.closest_artifact_report_true_pos.z, _x.closest_artifact_report_reported_pos.x, _x.closest_artifact_report_reported_pos.y, _x.closest_artifact_report_reported_pos.z, _x.closest_artifact_report_distance, _x.first_artifact_report_time, _x.last_artifact_report_time, _x.mean_time_between_successful_artifact_reports, _x.greatest_distance_traveled.data,) = _get_struct_11d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_distance_traveled.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_distance_traveled.name = str[start:end]
      start = end
      end += 8
      (self.greatest_euclidean_distance_from_start.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_euclidean_distance_from_start.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_euclidean_distance_from_start.name = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.total_distance_traveled, _x.greatest_max_vel.data,) = _get_struct_2d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_max_vel.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_max_vel.name = str[start:end]
      start = end
      end += 8
      (self.greatest_avg_vel.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_avg_vel.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_avg_vel.name = str[start:end]
      start = end
      end += 8
      (self.greatest_elevation_gain.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_elevation_gain.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_elevation_gain.name = str[start:end]
      start = end
      end += 8
      (self.greatest_elevation_loss.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_elevation_loss.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_elevation_loss.name = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.total_elevation_gain, _x.total_elevation_loss, _x.max_elevation_reached.data,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.max_elevation_reached.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.max_elevation_reached.name = str[start:end]
      start = end
      end += 8
      (self.min_elevation_reached.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.min_elevation_reached.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.min_elevation_reached.name = str[start:end]
      self.timestamp.canon()
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2I().pack(_x.timestamp.secs, _x.timestamp.nsecs))
      _x = self.world_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.robots)
      buff.write(_struct_I.pack(length))
      for val1 in self.robots:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.platform
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.marsupials)
      buff.write(_struct_I.pack(length))
      for val1 in self.marsupials:
        _x = val1.parent
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.child
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7i().pack(_x.artifacts_found, _x.robot_count, _x.unique_robot_count, _x.sim_time_elapsed, _x.real_time_elapsed, _x.artifact_report_count, _x.duplicate_report_count))
      _x = self.closest_artifact_report_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.closest_artifact_report_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_11d().pack(_x.closest_artifact_report_true_pos.x, _x.closest_artifact_report_true_pos.y, _x.closest_artifact_report_true_pos.z, _x.closest_artifact_report_reported_pos.x, _x.closest_artifact_report_reported_pos.y, _x.closest_artifact_report_reported_pos.z, _x.closest_artifact_report_distance, _x.first_artifact_report_time, _x.last_artifact_report_time, _x.mean_time_between_successful_artifact_reports, _x.greatest_distance_traveled.data))
      _x = self.greatest_distance_traveled.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_euclidean_distance_from_start.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_euclidean_distance_from_start.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2d().pack(_x.total_distance_traveled, _x.greatest_max_vel.data))
      _x = self.greatest_max_vel.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_avg_vel.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_avg_vel.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_elevation_gain.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_elevation_gain.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.greatest_elevation_loss.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.greatest_elevation_loss.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d().pack(_x.total_elevation_gain, _x.total_elevation_loss, _x.max_elevation_reached.data))
      _x = self.max_elevation_reached.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.min_elevation_reached.data
      buff.write(_get_struct_d().pack(_x))
      _x = self.min_elevation_reached.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.timestamp is None:
        self.timestamp = genpy.Time()
      if self.robots is None:
        self.robots = None
      if self.marsupials is None:
        self.marsupials = None
      if self.closest_artifact_report_true_pos is None:
        self.closest_artifact_report_true_pos = geometry_msgs.msg.Vector3()
      if self.closest_artifact_report_reported_pos is None:
        self.closest_artifact_report_reported_pos = geometry_msgs.msg.Vector3()
      if self.greatest_distance_traveled is None:
        self.greatest_distance_traveled = subt_ros.msg.RobotMetric()
      if self.greatest_euclidean_distance_from_start is None:
        self.greatest_euclidean_distance_from_start = subt_ros.msg.RobotMetric()
      if self.greatest_max_vel is None:
        self.greatest_max_vel = subt_ros.msg.RobotMetric()
      if self.greatest_avg_vel is None:
        self.greatest_avg_vel = subt_ros.msg.RobotMetric()
      if self.greatest_elevation_gain is None:
        self.greatest_elevation_gain = subt_ros.msg.RobotMetric()
      if self.greatest_elevation_loss is None:
        self.greatest_elevation_loss = subt_ros.msg.RobotMetric()
      if self.max_elevation_reached is None:
        self.max_elevation_reached = subt_ros.msg.RobotMetric()
      if self.min_elevation_reached is None:
        self.min_elevation_reached = subt_ros.msg.RobotMetric()
      end = 0
      _x = self
      start = end
      end += 8
      (_x.timestamp.secs, _x.timestamp.nsecs,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.world_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.world_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.robots = []
      for i in range(0, length):
        val1 = subt_ros.msg.Robot()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.platform = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.platform = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.type = str[start:end]
        self.robots.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.marsupials = []
      for i in range(0, length):
        val1 = subt_ros.msg.Marsupial()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.parent = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.parent = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.child = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.child = str[start:end]
        self.marsupials.append(val1)
      _x = self
      start = end
      end += 28
      (_x.artifacts_found, _x.robot_count, _x.unique_robot_count, _x.sim_time_elapsed, _x.real_time_elapsed, _x.artifact_report_count, _x.duplicate_report_count,) = _get_struct_7i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.closest_artifact_report_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.closest_artifact_report_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.closest_artifact_report_type = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.closest_artifact_report_type = str[start:end]
      _x = self
      start = end
      end += 88
      (_x.closest_artifact_report_true_pos.x, _x.closest_artifact_report_true_pos.y, _x.closest_artifact_report_true_pos.z, _x.closest_artifact_report_reported_pos.x, _x.closest_artifact_report_reported_pos.y, _x.closest_artifact_report_reported_pos.z, _x.closest_artifact_report_distance, _x.first_artifact_report_time, _x.last_artifact_report_time, _x.mean_time_between_successful_artifact_reports, _x.greatest_distance_traveled.data,) = _get_struct_11d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_distance_traveled.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_distance_traveled.name = str[start:end]
      start = end
      end += 8
      (self.greatest_euclidean_distance_from_start.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_euclidean_distance_from_start.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_euclidean_distance_from_start.name = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.total_distance_traveled, _x.greatest_max_vel.data,) = _get_struct_2d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_max_vel.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_max_vel.name = str[start:end]
      start = end
      end += 8
      (self.greatest_avg_vel.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_avg_vel.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_avg_vel.name = str[start:end]
      start = end
      end += 8
      (self.greatest_elevation_gain.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_elevation_gain.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_elevation_gain.name = str[start:end]
      start = end
      end += 8
      (self.greatest_elevation_loss.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.greatest_elevation_loss.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.greatest_elevation_loss.name = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.total_elevation_gain, _x.total_elevation_loss, _x.max_elevation_reached.data,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.max_elevation_reached.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.max_elevation_reached.name = str[start:end]
      start = end
      end += 8
      (self.min_elevation_reached.data,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.min_elevation_reached.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.min_elevation_reached.name = str[start:end]
      self.timestamp.canon()
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_11d = None
def _get_struct_11d():
    global _struct_11d
    if _struct_11d is None:
        _struct_11d = struct.Struct("<11d")
    return _struct_11d
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2d = None
def _get_struct_2d():
    global _struct_2d
    if _struct_2d is None:
        _struct_2d = struct.Struct("<2d")
    return _struct_2d
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_7i = None
def _get_struct_7i():
    global _struct_7i
    if _struct_7i is None:
        _struct_7i = struct.Struct("<7i")
    return _struct_7i
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
